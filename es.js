self.idroscalo=function(e){"use strict";
/*! (c) Andrea Giammarchi - ISC */const{isArray:t}=Array,{assign:n,keys:o}=Object;return e.hydrate=(e,r,c)=>{const s=new Map,a=new WeakMap,i=[];let l=0;const u=()=>{l||(l=setTimeout(f,0))},f=()=>{l=0,d();for(const n of o(r)){const c=r[n];for(const r of e.querySelectorAll(n))for(const e of o(c)){const o=c[e];if("^"===e){let e=s.get(n);e||s.set(n,e=new WeakSet),e.has(r)||(e.add(r),o({currentTarget:r,target:r,selector:n}));continue}const l=t(o),u=[e].concat(l?o:[o,!1]);let f=!0;if(l&&"object"==typeof u[2]&&u[2].once){f=!f;let e=a.get(r);if(e||a.set(r,e=new Set),e.has(u[1]))continue;e.add(u[1])}r.addEventListener.apply(r,u),f&&i.push({e:r,a:u})}}},d=()=>{for(const{e:e,a:t}of i.splice(0))e.removeEventListener.apply(e,t)},p=new MutationObserver(u),{disconnect:y}=p;return p.observe(e,n({subtree:!0,childList:!0},c)),p.disconnect=function(){return clearTimeout(l),d(),s.clear(),y.call(p)},u(),p},e.init="^",e}({});
